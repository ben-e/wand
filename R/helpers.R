#' Store a `torch` module as a raw R object.
#'
#' This function is used to store `torch` modules, usually after training, as raw R objects. This
#' function comes directly from the `brulee` package.
#'
#' @param model A `torch` module.
#'
#' @return A raw object.
dehydrate_model <- function(model) {
  con <- rawConnection(raw(), open = "w")
  on.exit({close(con)}, add = TRUE)
  torch::torch_save(model, con)
  r <- rawConnectionValue(con)
  r
}

#' Load models from raw objects.
#'
#' This function is used to restore dehydrated `torch` modules from raw R objects. This function
#' comes directly from the `brulee` package.
#'
#' @param model A raw object representing a `torch` module.
#'
#' @return A `torch` module.
hydrate_model <- function(model) {
  con <- rawConnection(model)
  on.exit({close(con)}, add = TRUE)
  module <- torch::torch_load(con)
  module
}

#' Scales an outcome given a list containing mean and sd.
#'
#' This function comes from brulee. It is used to scale the outcome before training and prediction.
#'
#' @param y The numeric outcome of interest.
#' @param stats A named list containing `mean` and `sd` entries.
#'
#' @return The scaled `y` value
scale_y <- function(y, stats) {
  if (is.factor(y))
    rlang::abort("Factors can not be scaled.")

  (y - stats$mean)/stats$sd
}

#' Validate a formula for a smooth specification.
#'
#' @param formula A formula.
#'
#' @return The unchanged formula.
validate_smooth_formula <- function(formula) {
  if (!is.null(rlang::f_lhs(formula)))
    rlang::abort("Formulas for smooth specifications can not contain a left hand side.")

  formula
}

#' Combine ... into a RHS only formula
#'
#' @param ... An unquoted set of terms to be combined into a formula.
#'
#' @return A RHS-only formula generated by just adding the ... terms.
dots_to_formula <- function(...) {
  dots <- rlang::enquos(...)
  stats::as.formula(paste0(" ~ ", paste0(sapply(dots, rlang::quo_name), collapse = " + ")))
}

#' Takes a formula, and replaces any smooth specs with the corresponding formula. Returns the
#' updated formula and the smooth specs extracted from the formula
#'
#' @param formula A formula that may contain `wand` `s_` functions.
#'
#' @return A named list with a `formula` and `smooth_specs` entries. The `formula` matches the input
#'   formula, but with all `s_` functions replaced with just their contents. The `smooth_specs`
#'   entry contains a list of smooth specifications.
extract_smooths <- function(formula) {
  smooth_specs <- list()
  for (term in attr(stats::terms(formula), "term.labels")) {
    # TODO I don't like that this assumes/requires that smoothers start with s_, perhaps
    # use a registry of smoothers? See parsnip's tracking of available models as an alternative.
    if (grepl("^s_", term)) {
      # get the actual smooth specification by evaluating the s function and save
      smooth_specs[[length(smooth_specs) + 1]] <- eval(parse(text = term))
      # update formula to remove the smooth, but keep the term
      formula <- stats::update.formula(
        formula,
        paste0(c(
          ". ~ .",
          " - ", term,
          " + ",  rlang::f_rhs(smooth_specs[[length(smooth_specs)]]$formula)
        ), collapse = "")
      )
    }
  }

  list(formula = formula,
       smooth_specs = smooth_specs)
}

#' Get mean 1d distance between points
#'
#' @param x A vector.
#'
#' @return The average distance between `x` points.
spacing <- function(x) {
  if (!is.numeric(x)) {
    rlang::abort("`x` is not a valid type.")
  }

  x <- sort(unique(x))
  x_spacing <- sapply(2:length(x), \(i) x[i] - x[i - 1])
  mean(x_spacing)
}

# Borrowing this from the modelr package
# https://github.com/tidyverse/modelr/blob/main/R/typical.R
typical <- function(x, ...) {
  UseMethod("typical")
}

typical.numeric <- function(x, ...) {
  stats::median(x, na.rm = TRUE)
}

typical.factor <- function(x, ...) {
  counts <- table(x, exclude = NULL)
  typ <- levels(x)[max(counts) == counts]
  factor(typ[1], levels = levels(x))
}

typical.character <- function(x, ...) {
  counts <- table(x, exclude = NULL)
  typ <- names(counts)[max(counts) == counts]
  typ[1]
}

typical.logical <- function(x, ...) {
  mean(x, na.rm = TRUE) >= 0.5
}

typical.integer <- function(x, ...) {
  unname(stats::quantile(x, 0.5, type = 1, na.rm = TRUE))
}

typical.ordered <- function(x, ...) {
  typ <- levels(x)[stats::quantile(as.integer(x), 0.5, type = 1, na.rm = TRUE)]
  factor(typ, levels = levels(x), ordered = T)
}

build_typical_df <- function(x, ...) {
  UseMethod("build_typical_df")
}

build_typical_df.data.frame <- function(x, ...) {
  typical_df <- dplyr::summarise(x, dplyr::across(.fns = typical))
  typical_df$.metric <- "typical"

  spacing_df <- dplyr::summarise(x, dplyr::across(where(is.numeric), spacing))
  spacing_df$.metric <- "spacing"

  min_df <- dplyr::summarise(x, dplyr::across(where(is.numeric), min))
  min_df$.metric <- "min"

  max_df <- dplyr::summarise(x, dplyr::across(where(is.numeric), max))
  max_df$.metric <- "max"

  typical_df <- dplyr::bind_rows(typical_df, spacing_df, min_df, max_df)

  typical_df
}

build_typical_df.matrix <- function(x, ...) {
  typical_df <- as.data.frame(t(apply(x, 2, typical)))
  typical_df$.metric <- "typical"

  spacing_df <- as.data.frame(t(apply(x, 2, spacing)))
  spacing_df$.metric <- "spacing"

  min_df <- as.data.frame(t(apply(x, 2, min)))
  min_df$.metric <- "min"

  max_df <- as.data.frame(t(apply(x, 2, max)))
  max_df$.metric <- "max"

  typical_df <- dplyr::bind_rows(typical_df, spacing_df, min_df, max_df)

  typical_df
}
